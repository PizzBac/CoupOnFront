{"ast":null,"code":"import React, { createContext, useState, useRef, useEffect, useContext } from 'react';\nimport SockJS from 'sockjs-client';\nimport { Client } from '@stomp/stompjs';\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nconst StompContext = createContext(undefined);\nconst _excluded = [\"url\", \"children\", \"stompClientOptions\"];\n/**\r\n * The StompSessionProvider manages the STOMP connection\r\n * All Hooks and HOCs in this library require an ancestor of this type.\r\n * The URL to connect to can be specified via the url prop.\r\n * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.\r\n * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs\r\n * Custom @stomp/stompjs options can be used as props.\r\n * Please consult the @stomp/stompjs documentation for more information.\r\n */\n\nfunction StompSessionProvider(props) {\n  let {\n      url,\n      children,\n      stompClientOptions\n    } = props,\n    stompOptions = _objectWithoutPropertiesLoose(props, _excluded); // Support old API\n\n  if (stompClientOptions) stompOptions = stompClientOptions;\n  const [client, setClient] = useState(undefined);\n  const subscriptionRequests = useRef(new Map());\n  useEffect(() => {\n    const _client = new Client(stompOptions);\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        var _window, _window$location;\n        const parsedUrl = new URL(url, (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href);\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url);\n        } else if (parsedUrl.protocol === 'ws:' || parsedUrl.protocol === 'wss:') {\n          return new WebSocket(url);\n        } else throw new Error('Protocol not supported');\n      };\n    }\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n      subscriptionRequests.current.forEach(value => {\n        value.subscription = _client.subscribe(value.destination, value.callback, value.headers);\n      });\n      setClient(_client);\n    };\n    _client.onWebSocketClose = function (event) {\n      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);\n      setClient(undefined);\n    };\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n    _client.activate();\n    return () => {\n      _client.deactivate();\n    };\n  }, [url, ...Object.values(stompOptions)]);\n  const subscribe = function (destination, callback) {\n    let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const subscriptionId = Math.random().toString(36).substr(2, 9);\n    const subscriptionRequest = {\n      destination,\n      callback,\n      headers\n    };\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(destination, callback, headers);\n    }\n    return () => {\n      const subscriptionData = subscriptionRequests.current.get(subscriptionId);\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n      subscriptionRequests.current.delete(subscriptionId);\n    };\n  };\n  return React.createElement(StompContext.Provider, {\n    value: {\n      client,\n      subscribe\n    }\n  }, children);\n}\n\n/**\r\n *\r\n * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.\r\n * @param onMessage Callback called when a message arrives for this subscription\r\n * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.\r\n */\n\nfunction useSubscription(destinations, onMessage) {\n  let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const stompContext = useContext(StompContext);\n  if (stompContext === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');\n  const callbackRef = useRef(onMessage);\n  const _destinations = Array.isArray(destinations) ? destinations : [destinations];\n  callbackRef.current = onMessage;\n  useEffect(() => {\n    const cleanUpFunctions = [];\n    _destinations.forEach(_destination => cleanUpFunctions.push(stompContext.subscribe(_destination, message => {\n      callbackRef.current(message);\n    }, headers)));\n    return () => {\n      cleanUpFunctions.forEach(_cleanUpFunction => {\n        _cleanUpFunction();\n      });\n    };\n  }, [Object.values(_destinations).toString(), Object.values(headers).toString()]);\n}\n\n/**\r\n * Returns the Stomp Client from @stomp/stompjs\r\n * This will be undefined if the client is currently not connected\r\n */\n\nfunction useStompClient() {\n  const context = useContext(StompContext);\n  if (context === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');\n  return context.client;\n}\nfunction withStompClient(WrappedComponent) {\n  return props => {\n    const stompClient = useStompClient();\n    return React.createElement(WrappedComponent, Object.assign({\n      stompClient: stompClient\n    }, props));\n  };\n}\nfunction withSubscription(WrappedComponent, destinations) {\n  let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return props => {\n    const ref = useRef();\n    useSubscription(destinations, message => {\n      if (ref.current) ref.current.onMessage(message);\n    }, headers); // @ts-ignore\n\n    return React.createElement(WrappedComponent, Object.assign({\n      ref: ref\n    }, props));\n  };\n}\nconst subscriptions = new Map();\nfunction subscribeMock(destination, callback) {\n  let headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const subscriptionId = Math.random().toString(36).substr(2, 9);\n  if (!subscriptions.has(destination)) {\n    subscriptions.set(destination, new Map());\n  } // @ts-ignore\n\n  subscriptions.get(destination).set(subscriptionId, callback);\n  return () => {\n    // @ts-ignore\n    subscriptions.get(destination).delete(subscriptionId);\n  };\n}\n/**\r\n * Simulates receiving a message from the server to the specified destination\r\n * @param destination The topic to send the message to\r\n * @param message The message to send\r\n */\n\nfunction mockReceiveMessage(destination, message) {\n  if (subscriptions.has(destination)) {\n    // @ts-ignore\n    subscriptions.get(destination).forEach(callback => {\n      callback(message);\n    });\n  }\n}\n/**\r\n * Gets the current subscriptions for the specified destination\r\n * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions\r\n */\n\nfunction getMockSubscriptions(destination) {\n  if (destination) {\n    return subscriptions.get(destination);\n  }\n  return subscriptions;\n}\nconst messages = new Map();\n/**\r\n * A mock implementation of the publish function of the @stomp/stompjs client.\r\n * Will store the messages in a map, keyed by the destination.\r\n * @param params\r\n */\n\nfunction mockClientPublish(params) {\n  if (!messages.has(params.destination)) {\n    messages.set(params.destination, []);\n  } // @ts-ignore\n\n  messages.get(params.destination).push(params);\n}\n/**\r\n * Gets a default Mock of the @stomp/stompjs client.\r\n * If you require a custom client, you can use this as a base.\r\n */\n\nfunction getMockClient() {\n  return {\n    publish: mockClientPublish\n  };\n}\n/**\r\n * Gets all messages which have been sent via a mock client.\r\n * @param destination The destination to get messages for, or undefined to get all messages.\r\n */\n\nfunction getSentMockMessages(destination) {\n  if (destination) {\n    return messages.get(destination);\n  }\n  return messages;\n}\n\n/**\r\n * A mock StompSessionProvider.\r\n * Messages send via this mock implementation can be received via the getSentMockMessages method.\r\n * Subscriptions can be received via the getMockSubscriptions method.\r\n * The sendMockMessage method can be used, to simulate receiving a message from the server.\r\n *\r\n * @param props.client Optional. Can be used to provide a custom mock of the sompjs client,\r\n * in case you require additional properties/functions to be present. getMockClient can be used as a base.\r\n * @constructor\r\n */\n\nfunction StompSessionProviderMock(props) {\n  var _props$client;\n  return React.createElement(StompContext.Provider, {\n    value: {\n      subscribe: subscribeMock,\n      // @ts-ignore\n      client: (_props$client = props.client) != null ? _props$client : getMockClient()\n    }\n  }, props.children);\n}\n\n/**\r\n * Resets the state of the mock implementation, clearing all subscriptions and messages.\r\n */\n\nfunction reset() {\n  subscriptions.clear();\n  messages.clear();\n}\nvar index = {\n  __proto__: null,\n  StompSessionProviderMock: StompSessionProviderMock,\n  getMockClient: getMockClient,\n  mockClientPublish: mockClientPublish,\n  mockReceiveMessage: mockReceiveMessage,\n  getSentMockMessages: getSentMockMessages,\n  reset: reset,\n  getMockSubscriptions: getMockSubscriptions\n};\nexport { StompSessionProvider, index as mock, useStompClient, useSubscription, withStompClient, withSubscription };","map":{"version":3,"names":["StompContext","createContext","undefined","StompSessionProvider","props","url","children","stompClientOptions","stompOptions","_objectWithoutPropertiesLoose","_excluded","client","setClient","useState","subscriptionRequests","useRef","Map","useEffect","_client","Client","brokerURL","webSocketFactory","_window","_window$location","parsedUrl","URL","window","location","href","protocol","SockJS","WebSocket","Error","onConnect","frame","current","forEach","value","subscription","subscribe","destination","callback","headers","onWebSocketClose","event","onStompError","activate","deactivate","Object","values","arguments","length","subscriptionId","Math","random","toString","substr","subscriptionRequest","set","connected","subscriptionData","get","unsubscribe","delete","React","createElement","Provider","useSubscription","destinations","onMessage","stompContext","useContext","callbackRef","_destinations","Array","isArray","cleanUpFunctions","_destination","push","message","_cleanUpFunction","useStompClient","context","withStompClient","WrappedComponent","stompClient","assign","withSubscription","ref","subscriptions","subscribeMock","has","mockReceiveMessage","getMockSubscriptions","messages","mockClientPublish","params","getMockClient","publish","getSentMockMessages","StompSessionProviderMock","_props$client","reset","clear"],"sources":["/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/context/StompContext.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/components/StompSessionProvider.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/hooks/useSubscription.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/hooks/useStompClient.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/hoc/withStompClient.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/hoc/withSubscription.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/mock/subscriptions.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/mock/client.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/mock/StompSessionProviderMock.tsx","/Users/joshhartnett/CoupOnFrontLocal/CoupOnFront-1/FrontRoot/node_modules/react-stomp-hooks/src/mock/reset.tsx"],"sourcesContent":["import { createContext } from 'react';\nimport { StompSessionProviderContext } from '../interfaces/StompSessionProviderContext';\n\nconst StompContext = createContext<StompSessionProviderContext | undefined>(\n  undefined\n);\n\nexport default StompContext;\n","import React, { useEffect, useRef, useState } from 'react';\nimport StompContext from '../context/StompContext';\nimport SockJS from 'sockjs-client';\nimport {\n  Client,\n  IStompSocket,\n  messageCallbackType,\n  StompHeaders\n} from '@stomp/stompjs';\nimport { StompSessionProviderProps } from '../interfaces/StompSessionProviderProps';\nimport { StompSessionSubscription } from '../interfaces/StompSessionSubscription';\n\n/**\n * The StompSessionProvider manages the STOMP connection\n * All Hooks and HOCs in this library require an ancestor of this type.\n * The URL to connect to can be specified via the url prop.\n * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.\n * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs\n * Custom @stomp/stompjs options can be used as props.\n * Please consult the @stomp/stompjs documentation for more information.\n */\nfunction StompSessionProvider(props: StompSessionProviderProps) {\n  let { url, children, stompClientOptions, ...stompOptions } = props;\n\n  // Support old API\n  if (stompClientOptions) stompOptions = stompClientOptions;\n\n  const [client, setClient] = useState<Client | undefined>(undefined);\n  const subscriptionRequests = useRef(new Map());\n\n  useEffect(() => {\n    const _client = new Client(stompOptions);\n\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        const parsedUrl = new URL(url, window?.location?.href);\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url) as IStompSocket;\n        } else if (\n          parsedUrl.protocol === 'ws:' ||\n          parsedUrl.protocol === 'wss:'\n        ) {\n          return new WebSocket(url) as IStompSocket;\n        } else throw new Error('Protocol not supported');\n      };\n    }\n\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n\n      subscriptionRequests.current.forEach((value) => {\n        value.subscription = _client.subscribe(\n          value.destination,\n          value.callback,\n          value.headers\n        );\n      });\n\n      setClient(_client);\n    };\n\n    _client.onWebSocketClose = function (event) {\n      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);\n\n      setClient(undefined);\n    };\n\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n\n    _client.activate();\n\n    return () => {\n      _client.deactivate();\n    };\n  }, [url, ...Object.values(stompOptions)]);\n\n  const subscribe = (\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ) => {\n    const subscriptionId = Math.random().toString(36).substr(2, 9);\n    const subscriptionRequest: StompSessionSubscription = {\n      destination,\n      callback,\n      headers\n    };\n\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(\n        destination,\n        callback,\n        headers\n      );\n    }\n\n    return () => {\n      const subscriptionData = subscriptionRequests.current.get(subscriptionId);\n\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n\n      subscriptionRequests.current.delete(subscriptionId);\n    };\n  };\n\n  return (\n    <StompContext.Provider\n      value={{\n        client,\n        subscribe\n      }}\n    >\n      {children}\n    </StompContext.Provider>\n  );\n}\n\nexport default StompSessionProvider;\n","import { useContext, useEffect, useRef } from 'react';\nimport StompContext from '../context/StompContext';\nimport { messageCallbackType, StompHeaders } from '@stomp/stompjs';\n\n/**\n *\n * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.\n * @param onMessage Callback called when a message arrives for this subscription\n * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.\n */\nfunction useSubscription(\n  destinations: string | string[],\n  onMessage: messageCallbackType,\n  headers: StompHeaders = {}\n) {\n  const stompContext = useContext(StompContext);\n\n  if (stompContext === undefined)\n    throw new Error(\n      'There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs'\n    );\n\n  const callbackRef = useRef<messageCallbackType>(onMessage);\n  const _destinations = Array.isArray(destinations)\n    ? destinations\n    : [destinations];\n\n  callbackRef.current = onMessage;\n\n  useEffect(() => {\n    const cleanUpFunctions: (() => void)[] = [];\n\n    _destinations.forEach((_destination) =>\n      cleanUpFunctions.push(\n        stompContext.subscribe(\n          _destination,\n          (message) => {\n            callbackRef.current(message);\n          },\n          headers\n        )\n      )\n    );\n\n    return () => {\n      cleanUpFunctions.forEach((_cleanUpFunction) => {\n        _cleanUpFunction();\n      });\n    };\n  }, [\n    Object.values(_destinations).toString(),\n    Object.values(headers).toString()\n  ]);\n}\n\nexport default useSubscription;\n","import { useContext } from 'react';\nimport StompContext from '../context/StompContext';\nimport { StompSessionProviderContext } from '../interfaces/StompSessionProviderContext';\n\n/**\n * Returns the Stomp Client from @stomp/stompjs\n * This will be undefined if the client is currently not connected\n */\nfunction useStompClient() {\n  const context = useContext<StompSessionProviderContext | undefined>(\n    StompContext\n  );\n\n  if (context === undefined)\n    throw new Error(\n      'There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs'\n    );\n\n  return context.client;\n}\n\nexport default useStompClient;\n","import React from 'react';\nimport useStompClient from '../hooks/useStompClient';\n\nfunction withStompClient<P>(WrappedComponent: React.ComponentType<P>) {\n  return (props: P) => {\n    const stompClient = useStompClient();\n    return <WrappedComponent stompClient={stompClient} {...props} />;\n  };\n}\n\nexport default withStompClient;\n","import React, { useRef } from 'react';\nimport useSubscription from '../hooks/useSubscription';\nimport { StompHeaders } from '@stomp/stompjs';\nimport {\n  MessageReceiverInterface,\n  StompMessageReceiver\n} from '../interfaces/StompMessageReceiver';\nimport { IMessage } from '@stomp/stompjs/esm6/i-message';\n\nfunction withSubscription<P>(\n  WrappedComponent: StompMessageReceiver<P>,\n  destinations: string | string[],\n  headers: StompHeaders = {}\n) {\n  return (props: P) => {\n    const ref = useRef<MessageReceiverInterface>();\n    useSubscription(\n      destinations,\n      (message: IMessage) => {\n        if (ref.current) ref.current.onMessage(message);\n      },\n      headers\n    );\n\n    // @ts-ignore\n    return <WrappedComponent ref={ref} {...props} />;\n  };\n}\n\nexport default withSubscription;\n","import { IMessage } from '@stomp/stompjs/src/i-message';\nimport { messageCallbackType, StompHeaders } from '@stomp/stompjs';\n\nexport const subscriptions = new Map<string, Map<string, Function>>();\n\nexport function subscribeMock(\n  destination: string,\n  callback: messageCallbackType,\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  headers: StompHeaders = {}\n) {\n  const subscriptionId = Math.random().toString(36).substr(2, 9);\n\n  if (!subscriptions.has(destination)) {\n    subscriptions.set(destination, new Map<string, Function>());\n  }\n\n  // @ts-ignore\n  subscriptions.get(destination).set(subscriptionId, callback);\n\n  return () => {\n    // @ts-ignore\n    subscriptions.get(destination).delete(subscriptionId);\n  };\n}\n\n/**\n * Simulates receiving a message from the server to the specified destination\n * @param destination The topic to send the message to\n * @param message The message to send\n */\nexport function mockReceiveMessage(\n  destination: string,\n  message: IMessage\n): void {\n  if (subscriptions.has(destination)) {\n    // @ts-ignore\n    subscriptions.get(destination).forEach((callback: Function) => {\n      callback(message);\n    });\n  }\n}\n\n/**\n * Gets the current subscriptions for the specified destination\n * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions\n */\nexport function getMockSubscriptions(destination?: string) {\n  if (destination) {\n    return subscriptions.get(destination);\n  }\n  return subscriptions;\n}\n","import { IPublishParams } from '@stomp/stompjs';\n\nexport const messages = new Map<string, Array<IPublishParams>>();\n\n/**\n * A mock implementation of the publish function of the @stomp/stompjs client.\n * Will store the messages in a map, keyed by the destination.\n * @param params\n */\nexport function mockClientPublish(params: IPublishParams) {\n  if (!messages.has(params.destination)) {\n    messages.set(params.destination, []);\n  }\n\n  // @ts-ignore\n  messages.get(params.destination).push(params);\n}\n\n/**\n * Gets a default Mock of the @stomp/stompjs client.\n * If you require a custom client, you can use this as a base.\n */\nexport function getMockClient() {\n  return {\n    publish: mockClientPublish\n  };\n}\n\n/**\n * Gets all messages which have been sent via a mock client.\n * @param destination The destination to get messages for, or undefined to get all messages.\n */\nexport function getSentMockMessages(destination?: string) {\n  if (destination) {\n    return messages.get(destination);\n  }\n  return messages;\n}\n","import React from 'react';\nimport StompContext from '../context/StompContext';\nimport { subscribeMock } from './subscriptions';\nimport { getMockClient } from './client';\n\n/**\n * A mock StompSessionProvider.\n * Messages send via this mock implementation can be received via the getSentMockMessages method.\n * Subscriptions can be received via the getMockSubscriptions method.\n * The sendMockMessage method can be used, to simulate receiving a message from the server.\n *\n * @param props.client Optional. Can be used to provide a custom mock of the sompjs client,\n * in case you require additional properties/functions to be present. getMockClient can be used as a base.\n * @constructor\n */\nexport default function StompSessionProviderMock(props: {\n  children: React.ReactNode;\n  client?: any;\n}) {\n  return (\n    <StompContext.Provider\n      value={{\n        subscribe: subscribeMock,\n        // @ts-ignore\n        client: props.client ?? getMockClient()\n      }}\n    >\n      {props.children}\n    </StompContext.Provider>\n  );\n}\n","import { subscriptions } from './subscriptions';\nimport { messages } from './client';\n\n/**\n * Resets the state of the mock implementation, clearing all subscriptions and messages.\n */\nexport function reset() {\n  subscriptions.clear();\n  messages.clear();\n}\n"],"mappings":";;;;;;;;;;;;;;;AAGA,MAAMA,YAAY,GAAGC,aAAa,CAChCC,SADgC,CAAlC;;ACSA;;;;;;;;AAQG;;AACH,SAASC,oBAATA,CAA8BC,KAA9B,EAA8D;EACxD;MAAEC,GAAF;MAAOC,QAAP;MAAiBC;IAAjB,IAAyDH,KAA7D;IAA4CI,YAA5C,GAAAC,6BAAA,CAA6DL,KAA7D,EAAAM,SAAA,EAD4D;;EAI5D,IAAIH,kBAAJ,EAAwBC,YAAY,GAAGD,kBAAf;EAElB,OAACI,MAAD,EAASC,SAAT,IAAsBC,QAAQ,CAAqBX,SAArB,CAApC;EACA,MAAMY,oBAAoB,GAAGC,MAAM,CAAC,IAAIC,GAAJ,EAAD,CAAnC;EAEAC,SAAS,CAAC,MAAK;IACb,MAAMC,OAAO,GAAG,IAAIC,MAAJ,CAAWX,YAAX,CAAhB;IAEI,KAACA,YAAY,CAACY,SAAd,IAA2B,CAACZ,YAAY,CAACa,gBAA7C,EAA+D;MAC7DH,OAAO,CAACG,gBAAR,GAA2B;QAAA,IAAAC,OAAA,EAAAC,gBAAA;QACzB,MAAMC,SAAS,GAAG,IAAIC,GAAJ,CAAQpB,GAAR,GAAAiB,OAAA,GAAaI,MAAb,sBAAAH,gBAAA,GAAaD,OAAQ,CAAAK,QAArB,KAAa,gBAAAJ,gBAAA,CAAkBK,IAA/B,CAAlB;QACI,IAAAJ,SAAS,CAACK,QAAV,KAAuB,OAAvB,IAAkCL,SAAS,CAACK,QAAV,KAAuB,QAA7D,EAAuE;UACrE,OAAO,IAAIC,MAAJ,CAAWzB,GAAX,CAAP;QACD,CAFD,MAEO,IACLmB,SAAS,CAACK,QAAV,KAAuB,KAAvB,IACAL,SAAS,CAACK,QAAV,KAAuB,MAFlB,EAGL;UACA,OAAO,IAAIE,SAAJ,CAAc1B,GAAd,CAAP;QACD,CALM,MAKA,MAAM,IAAI2B,KAAJ,CAAU,wBAAV,CAAN;MACR,CAVD;IAWD;IAEDd,OAAO,CAACe,SAAR,GAAoB,UAAUC,KAAV,EAAe;MAC7B,IAAA1B,YAAY,CAACyB,SAAjB,EAA4BzB,YAAY,CAACyB,SAAb,CAAuBC,KAAvB;MAE5BpB,oBAAoB,CAACqB,OAArB,CAA6BC,OAA7B,CAAsCC,KAAD,IAAU;QAC7CA,KAAK,CAACC,YAAN,GAAqBpB,OAAO,CAACqB,SAAR,CACnBF,KAAK,CAACG,WADa,EAEnBH,KAAK,CAACI,QAFa,EAGnBJ,KAAK,CAACK,OAHa,CAArB;MAKD,CAND;MAQA9B,SAAS,CAACM,OAAD,CAAT;IACD,CAZD;IAcAA,OAAO,CAACyB,gBAAR,GAA2B,UAAUC,KAAV,EAAe;MACpC,IAAApC,YAAY,CAACmC,gBAAjB,EAAmCnC,YAAY,CAACmC,gBAAb,CAA8BC,KAA9B;MAEnChC,SAAS,CAACV,SAAD,CAAT;IACD,CAJD;IAMA,IAAI,CAACM,YAAY,CAACqC,YAAlB,EAAgC;MAC9B3B,OAAO,CAAC2B,YAAR,GAAuB,UAAUX,KAAV,EAAe;QACpC,MAAMA,KAAN;MACD,CAFD;IAGD;IAEDhB,OAAO,CAAC4B,QAAR;IAEA,OAAO,MAAK;MACV5B,OAAO,CAAC6B,UAAR;IACD,CAFD;EAGD,CAhDQ,EAgDN,CAAC1C,GAAD,EAAM,GAAG2C,MAAM,CAACC,MAAP,CAAczC,YAAd,CAAT,CAhDM,CAAT;EAkDM,MAAA+B,SAAS,GAAG,SAAAA,CAChBC,WADgB,EAEhBC,QAFgB,EAId;IAAA,IADFC,OAAA,GAAAQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhD,SAAA,GAAAgD,SAAA,MAAwB,EAHR;IAKhB,MAAME,cAAc,GAAGC,IAAI,CAACC,MAAL,EAAc,CAAAC,QAAd,CAAuB,EAAvB,EAA2BC,MAA3B,CAAkC,CAAlC,EAAqC,CAArC,CAAvB;IACA,MAAMC,mBAAmB,GAA6B;MACpDjB,WADoD;MAEpDC,QAFoD;MAGpDC;IAHoD,CAAtD;IAMA5B,oBAAoB,CAACqB,OAArB,CAA6BuB,GAA7B,CAAiCN,cAAjC,EAAiDK,mBAAjD;IAEA,IAAI9C,MAAM,IAAIA,MAAM,CAACgD,SAArB,EAAgC;MAC9BF,mBAAmB,CAACnB,YAApB,GAAmC3B,MAAM,CAAC4B,SAAP,CACjCC,WADiC,EAEjCC,QAFiC,EAGjCC,OAHiC,CAAnC;IAKD;IAED,OAAO,MAAK;MACJ,MAAAkB,gBAAgB,GAAG9C,oBAAoB,CAACqB,OAArB,CAA6B0B,GAA7B,CAAiCT,cAAjC,CAAzB;MAEI,IAAAQ,gBAAgB,CAACtB,YAArB,EAAmC;QACjCsB,gBAAgB,CAACtB,YAAjB,CAA8BwB,WAA9B;MACD;MAEDhD,oBAAoB,CAACqB,OAArB,CAA6B4B,MAA7B,CAAoCX,cAApC;IACD,CARD;EASD,CA/BD;EAiCA,OACEY,KAAC,CAAAC,aAAD,CAACjE,YAAY,CAACkE,QAAd,EAAsB;IACpB7B,KAAK,EAAE;MACL1B,MADK;MAEL4B;IAFK;EADa,CAAtB,EAMGjC,QANH,CADF;AAUD;;ACvHD;;;;;AAKG;;AACH,SAAS6D,eAATA,CACEC,YADF,EAEEC,SAFF,EAG4B;EAAA,IAA1B3B,OAAA,GAAAQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhD,SAAA,GAAAgD,SAAA,MAAwB,EAH1B;EAKE,MAAMoB,YAAY,GAAGC,UAAU,CAACvE,YAAD,CAA/B;EAEI,IAAAsE,YAAY,KAAKpE,SAArB,EACE,MAAM,IAAI8B,KAAJ,CACJ,8EADI,CAAN;EAIF,MAAMwC,WAAW,GAAGzD,MAAM,CAAsBsD,SAAtB,CAA1B;EACA,MAAMI,aAAa,GAAGC,KAAK,CAACC,OAAN,CAAcP,YAAd,IAClBA,YADkB,GAElB,CAACA,YAAD,CAFJ;EAIAI,WAAW,CAACrC,OAAZ,GAAsBkC,SAAtB;EAEApD,SAAS,CAAC,MAAK;IACP,MAAA2D,gBAAgB,GAAmB,EAAzC;IAEAH,aAAa,CAACrC,OAAd,CAAuByC,YAAD,IACpBD,gBAAgB,CAACE,IAAjB,CACER,YAAY,CAAC/B,SAAb,CACEsC,YADF,EAEGE,OAAD,IAAY;MACVP,WAAW,CAACrC,OAAZ,CAAoB4C,OAApB;IACD,CAJH,EAKErC,OALF,CADF,CADF;IAYA,OAAO,MAAK;MACVkC,gBAAgB,CAACxC,OAAjB,CAA0B4C,gBAAD,IAAqB;QAC5CA,gBAAgB;MACjB,CAFD;IAGD,CAJD;EAKD,CApBQ,EAoBN,CACDhC,MAAM,CAACC,MAAP,CAAcwB,aAAd,EAA6BlB,QAA7B,EADC,EAEDP,MAAM,CAACC,MAAP,CAAcP,OAAd,EAAuBa,QAAvB,EAFC,CApBM,CAAT;AAwBD;;ACjDD;;;AAGG;;AACH,SAAS0B,cAATA,CAAA,EAAuB;EACrB,MAAMC,OAAO,GAAGX,UAAU,CACxBvE,YADwB,CAA1B;EAII,IAAAkF,OAAO,KAAKhF,SAAhB,EACE,MAAM,IAAI8B,KAAJ,CACJ,8EADI,CAAN;EAIK,OAAAkD,OAAO,CAACvE,MAAf;AACD;AChBD,SAASwE,eAATA,CAA4BC,gBAA5B,EAAoE;EAClE,OAAQhF,KAAD,IAAa;IACZ,MAAAiF,WAAW,GAAGJ,cAAc,EAAlC;IACO,OAAAjB,KAAA,CAAAC,aAAA,CAACmB,gBAAD,EAAkBpC,MAAA,CAAAsC,MAAA;MAAAD,WAAW,EAAEA;IAAb,GAA8BjF,KAA9B,CAAlB,CAAP;EACD,CAHD;AAID;ACCD,SAASmF,gBAATA,CACEH,gBADF,EAEEhB,YAFF,EAG4B;EAAA,IAA1B1B,OAAA,GAAAQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhD,SAAA,GAAAgD,SAAA,MAAwB,EAH1B;EAKE,OAAQ9C,KAAD,IAAa;IACZ,MAAAoF,GAAG,GAAGzE,MAAM,EAAlB;IACAoD,eAAe,CACbC,YADa,EAEZW,OAAD,IAAsB;MAChB,IAAAS,GAAG,CAACrD,OAAR,EAAiBqD,GAAG,CAACrD,OAAJ,CAAYkC,SAAZ,CAAsBU,OAAtB;IAClB,CAJY,EAKbrC,OALa,CAAf,CAFkB;;IAWX,OAAAsB,KAAA,CAAAC,aAAA,CAACmB,gBAAD,EAAkBpC,MAAA,CAAAsC,MAAA;MAAAE,GAAG,EAAEA;IAAL,GAAcpF,KAAd,CAAlB,CAAP;EACD,CAZD;AAaD;ACxBM,MAAMqF,aAAa,GAAG,IAAIzE,GAAJ,EAAtB;AAES,SAAA0E,cACdlD,WADc,EAEdC,QAFc,EAKY;EAAA,IAA1BC,OAAA,GAAAQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhD,SAAA,GAAAgD,SAAA,MAAwB,EALV;EAOd,MAAME,cAAc,GAAGC,IAAI,CAACC,MAAL,EAAc,CAAAC,QAAd,CAAuB,EAAvB,EAA2BC,MAA3B,CAAkC,CAAlC,EAAqC,CAArC,CAAvB;EAEA,IAAI,CAACiC,aAAa,CAACE,GAAd,CAAkBnD,WAAlB,CAAL,EAAqC;IACnCiD,aAAa,CAAC/B,GAAd,CAAkBlB,WAAlB,EAA+B,IAAIxB,GAAJ,EAA/B;EACD,CANyB;;EAS1ByE,aAAa,CAAC5B,GAAd,CAAkBrB,WAAlB,EAA+BkB,GAA/B,CAAmCN,cAAnC,EAAmDX,QAAnD;EAEA,OAAO,MAAK;IACV;IACAgD,aAAa,CAAC5B,GAAd,CAAkBrB,WAAlB,CAA+B,CAAAuB,MAA/B,CAAsCX,cAAtC;EACD,CAHD;AAID;AAED;;;;AAIG;;AACa,SAAAwC,mBACdpD,WADc,EAEduC,OAFc,EAEG;EAEjB,IAAIU,aAAa,CAACE,GAAd,CAAkBnD,WAAlB,CAAJ,EAAoC;IAClC;IACAiD,aAAa,CAAC5B,GAAd,CAAkBrB,WAAlB,CAA+B,CAAAJ,OAA/B,CAAwCK,QAAD,IAAuB;MAC5DA,QAAQ,CAACsC,OAAD,CAAR;IACD,CAFD;EAGD;AACF;AAED;;;AAGG;;AACG,SAAUc,oBAAVA,CAA+BrD,WAA/B,EAAmD;EACvD,IAAIA,WAAJ,EAAiB;IACf,OAAOiD,aAAa,CAAC5B,GAAd,CAAkBrB,WAAlB,CAAP;EACD;EACD,OAAOiD,aAAP;AACD;ACnDM,MAAMK,QAAQ,GAAG,IAAI9E,GAAJ,EAAjB;AAEP;;;;AAIG;;AACG,SAAU+E,iBAAVA,CAA4BC,MAA5B,EAAkD;EAClD,KAACF,QAAQ,CAACH,GAAT,CAAaK,MAAM,CAACxD,WAApB,CAAL,EAAuC;IACrCsD,QAAQ,CAACpC,GAAT,CAAasC,MAAM,CAACxD,WAApB,EAAiC,EAAjC;EACD,CAHqD;;EAMtDsD,QAAQ,CAACjC,GAAT,CAAamC,MAAM,CAACxD,WAApB,EAAiCsC,IAAjC,CAAsCkB,MAAtC;AACD;AAED;;;AAGG;;SACaC,cAAA,EAAa;EACpB;IACLC,OAAO,EAAEH;EADJ,CAAP;AAGD;AAED;;;AAGG;;AACG,SAAUI,mBAAVA,CAA8B3D,WAA9B,EAAkD;EACtD,IAAIA,WAAJ,EAAiB;IACf,OAAOsD,QAAQ,CAACjC,GAAT,CAAarB,WAAb,CAAP;EACD;EACD,OAAOsD,QAAP;AACD;;AChCD;;;;;;;;;AASG;;AACqB,SAAAM,yBAAyBhG,KAAzB,EAGvB;EAAA,IAAAiG,aAAA;EACC,OACErC,KAAC,CAAAC,aAAD,CAACjE,YAAY,CAACkE,QAAd,EAAsB;IACpB7B,KAAK,EAAE;MACLE,SAAS,EAAEmD,aADN;MAEL;MACA/E,MAAM,EAAE,CAAA0F,aAAA,GAAAjG,KAAK,CAACO,MAAR,YAAA0F,aAAA,GAAkBJ,aAAa;IAHhC;EADa,CAAtB,EAOG7F,KAAK,CAACE,QAPT,CADF;AAWD;;AC3BD;;AAEG;;SACagG,MAAA,EAAK;EACnBb,aAAa,CAACc,KAAd;EACAT,QAAQ,CAACS,KAAT;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}